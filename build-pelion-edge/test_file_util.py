#!/usr/bin/env python3
# Copyright (c) 2019, Arm Limited and Contributors. All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

import contextlib
import datetime
import functools
import os
import pytest
import stat
import tempfile

import file_util as fu


def test_ensure_is_regular_file():
    # Regular file that exists
    fu.ensure_is_regular_file(__file__)

    # Nonexistent file
    with pytest.raises(ValueError, match=r"exist"):
        fu.ensure_is_regular_file("nonexistentfile")

    # Existing non-regular file
    with pytest.raises(ValueError, match=r"regular"):
        fu.ensure_is_regular_file(os.path.dirname(__file__))


def test_ensure_is_directory():
    # Directory that exists
    fu.ensure_is_directory(os.path.dirname(__file__))

    # Nonexistent file
    with pytest.raises(ValueError, match=r"exist"):
        fu.ensure_is_directory("nonexistentfile")

    # Existing non-directory file
    with pytest.raises(ValueError, match=r"directory"):
        fu.ensure_is_directory(__file__)


BINARY_DATA1 = b"ab"
BINARY_DATA2 = b"cdef"


def test_atomic_read_modify_write_file_normal():
    with _read_modify_write_tester(
        BINARY_DATA1, BINARY_DATA2, binary_mode=True
    ) as test_file_path:
        with fu.atomic_read_modify_write_file(
            test_file_path, binary_mode=True
        ) as (reader, writer):
            reader.read()
            writer.write(BINARY_DATA2)


def test_atomic_read_modify_write_file_exception_before_read():
    with _read_modify_write_tester(
        BINARY_DATA1, BINARY_DATA1, binary_mode=True
    ) as test_file_path:
        with pytest.raises(RuntimeError, match=r"exception test"):
            with fu.atomic_read_modify_write_file(
                test_file_path, binary_mode=True
            ) as (reader, writer):
                raise RuntimeError("exception test")
                reader.read()
                writer.write(BINARY_DATA2)


def test_atomic_read_modify_write_file_exception_before_write():
    with _read_modify_write_tester(
        BINARY_DATA1, BINARY_DATA1, binary_mode=True
    ) as test_file_path:
        with pytest.raises(RuntimeError, match=r"exception test"):
            with fu.atomic_read_modify_write_file(
                test_file_path, binary_mode=True
            ) as (reader, writer):
                reader.read()
                raise RuntimeError("exception test")
                writer.write(BINARY_DATA2)


def test_atomic_read_modify_write_file_exception_after_write():
    with _read_modify_write_tester(
        BINARY_DATA1, BINARY_DATA1, binary_mode=True
    ) as test_file_path:
        with pytest.raises(RuntimeError, match=r"exception test"):
            with fu.atomic_read_modify_write_file(
                test_file_path, binary_mode=True
            ) as (reader, writer):
                reader.read()
                writer.write(BINARY_DATA2)
                raise RuntimeError("exception test")


def test_atomic_read_modify_write_file_invalid_path():
    with _read_modify_write_tester(
        BINARY_DATA1, BINARY_DATA1, binary_mode=True
    ) as test_file_path:
        with pytest.raises(FileNotFoundError):
            with fu.atomic_read_modify_write_file(
                "{}.invalid".format(test_file_path), binary_mode=True
            ) as (reader, writer):
                reader.read()
                writer.write(BINARY_DATA2)


def test_atomic_read_modify_write_file_perms():
    with _read_modify_write_tester(
        BINARY_DATA1, BINARY_DATA2, binary_mode=True
    ) as test_file_path:

        # Set a very unusual mode so that it's very unlikely to match the
        # user's umask. Need to keep owner read+write perms so that we can
        # still actually operate on the file though.
        orig_mode = 0o4613
        os.chmod(test_file_path, orig_mode)

        with fu.atomic_read_modify_write_file(
            test_file_path, binary_mode=True
        ) as (reader, writer):
            reader.read()
            writer.write(BINARY_DATA2)

        final_mode = stat.S_IMODE(os.stat(test_file_path).st_mode)
        assert oct(final_mode) == oct(orig_mode)


FAKE_DATETIME = datetime.datetime(year=2019, month=4, day=26)
COMMENT_LEADER = ";"
TEXT_DATA1 = "Text data 1\n"
TEXT_DATA2 = "Text data 2\n"
TEXT_DATA3 = "Text data 3\n"
TEXT_DATA4 = "Text data 4\n"
SECTION_NAME1 = "foo"
SECTION_NAME2 = "bar"

SECTION_HEADER1 = (
    "; BEGIN_AUTOGENERATED_SECTION: foo\n"
    "; Last modified: 2019-04-26T00:00:00\n"
)

SECTION_HEADER2 = (
    "; BEGIN_AUTOGENERATED_SECTION: bar\n"
    "; Last modified: 2019-04-26T00:00:00\n"
)

SECTION_FOOTER1 = "; END_AUTOGENERATED_SECTION: foo\n"
SECTION_FOOTER2 = "; END_AUTOGENERATED_SECTION: bar\n"


@pytest.fixture
def fake_datetime_now(monkeypatch):
    class FakeDatetime:
        @classmethod
        def now(cls):
            return FAKE_DATETIME

    monkeypatch.setattr(datetime, "datetime", FakeDatetime)


def test_replace_section_in_file_add(fake_datetime_now):
    orig_data = TEXT_DATA1
    final_data = "{}{}{}{}".format(
        orig_data, SECTION_HEADER1, TEXT_DATA2, SECTION_FOOTER1
    )
    with _read_modify_write_tester(orig_data, final_data) as test_file_path:
        with fu.replace_section_in_file(
            test_file_path, SECTION_NAME1, comment_leader=COMMENT_LEADER
        ) as writer:
            writer.write(TEXT_DATA2)


def test_replace_section_in_file_replace_at_end(fake_datetime_now):
    orig_data = "{}{}{}{}".format(
        TEXT_DATA1, SECTION_HEADER1, TEXT_DATA2, SECTION_FOOTER1
    )
    final_data = "{}{}{}{}".format(
        TEXT_DATA1, SECTION_HEADER1, TEXT_DATA3, SECTION_FOOTER1
    )
    with _read_modify_write_tester(orig_data, final_data) as test_file_path:
        with fu.replace_section_in_file(
            test_file_path, SECTION_NAME1, comment_leader=COMMENT_LEADER
        ) as writer:
            writer.write(TEXT_DATA3)


def test_replace_section_in_file_replace_in_middle(fake_datetime_now):
    orig_data = "{}{}{}{}{}".format(
        TEXT_DATA1, SECTION_HEADER1, TEXT_DATA2, SECTION_FOOTER1, TEXT_DATA3
    )
    final_data = "{}{}{}{}{}".format(
        TEXT_DATA1, SECTION_HEADER1, TEXT_DATA4, SECTION_FOOTER1, TEXT_DATA3
    )
    with _read_modify_write_tester(orig_data, final_data) as test_file_path:
        with fu.replace_section_in_file(
            test_file_path, SECTION_NAME1, comment_leader=COMMENT_LEADER
        ) as writer:
            writer.write(TEXT_DATA4)


def test_replace_section_in_file_with_other_section(fake_datetime_now):
    orig_data = "{}{}{}{}".format(
        TEXT_DATA1, SECTION_HEADER1, TEXT_DATA2, SECTION_FOOTER1
    )
    final_data = "{}{}{}{}".format(
        orig_data, SECTION_HEADER2, TEXT_DATA3, SECTION_FOOTER2
    )
    with _read_modify_write_tester(orig_data, final_data) as test_file_path:
        with fu.replace_section_in_file(
            test_file_path, SECTION_NAME2, comment_leader=COMMENT_LEADER
        ) as writer:
            writer.write(TEXT_DATA3)


def test_replace_section_in_file_with_missing_end_marker(fake_datetime_now):
    orig_data = "{}{}{}".format(TEXT_DATA1, SECTION_HEADER1, TEXT_DATA2)
    final_data = orig_data
    with _read_modify_write_tester(orig_data, final_data) as test_file_path:
        with pytest.raises(fu.UnexpectedEofInSectionError):
            with fu.replace_section_in_file(
                test_file_path, SECTION_NAME1, comment_leader=COMMENT_LEADER
            ) as writer:
                writer.write(TEXT_DATA3)


def test_replace_section_in_file_with_missing_start_marker(fake_datetime_now):
    orig_data = "{}{}".format(TEXT_DATA1, SECTION_FOOTER1)
    final_data = orig_data
    with _read_modify_write_tester(orig_data, final_data) as test_file_path:
        with pytest.raises(fu.UnexpectedSectionMarkerError):
            with fu.replace_section_in_file(
                test_file_path, SECTION_NAME1, comment_leader=COMMENT_LEADER
            ) as writer:
                writer.write(TEXT_DATA3)


def test_replace_section_in_file_with_double_start_marker(fake_datetime_now):
    orig_data = "{}{}{}{}{}".format(
        TEXT_DATA1,
        SECTION_HEADER1,
        SECTION_HEADER1,
        TEXT_DATA2,
        SECTION_FOOTER1,
    )
    final_data = orig_data
    with _read_modify_write_tester(orig_data, final_data) as test_file_path:
        with pytest.raises(fu.UnexpectedSectionMarkerError):
            with fu.replace_section_in_file(
                test_file_path, SECTION_NAME1, comment_leader=COMMENT_LEADER
            ) as writer:
                writer.write(TEXT_DATA3)


def test_replace_section_in_file_with_double_end_marker(fake_datetime_now):
    orig_data = "{}{}{}{}{}".format(
        TEXT_DATA1,
        SECTION_HEADER1,
        TEXT_DATA2,
        SECTION_FOOTER1,
        SECTION_FOOTER1,
    )
    final_data = orig_data
    with _read_modify_write_tester(orig_data, final_data) as test_file_path:
        with pytest.raises(fu.UnexpectedSectionMarkerError):
            with fu.replace_section_in_file(
                test_file_path, SECTION_NAME1, comment_leader=COMMENT_LEADER
            ) as writer:
                writer.write(TEXT_DATA4)


def test_replace_section_in_file_with_repeated_section(fake_datetime_now):
    orig_data = "{}{}{}{}{}{}{}".format(
        TEXT_DATA1,
        SECTION_HEADER1,
        TEXT_DATA2,
        SECTION_FOOTER1,
        SECTION_HEADER1,
        TEXT_DATA3,
        SECTION_FOOTER1,
    )
    final_data = orig_data
    with _read_modify_write_tester(orig_data, final_data) as test_file_path:
        with pytest.raises(fu.UnexpectedSectionMarkerError):
            with fu.replace_section_in_file(
                test_file_path, SECTION_NAME1, comment_leader=COMMENT_LEADER
            ) as writer:
                writer.write(TEXT_DATA4)


@contextlib.contextmanager
def _read_modify_write_tester(orig_data, final_data, binary_mode=False):
    with tempfile.TemporaryDirectory() as tmpdir:
        test_file_name = "testfile"
        test_file_path = os.path.join(tmpdir, test_file_name)
        _create_test_file(test_file_path, orig_data, binary_mode)
        yield test_file_path
        assert _read_test_file(test_file_path, binary_mode) == final_data
        assert os.listdir(tmpdir) == [test_file_name]


def _create_test_file(path, data, binary_mode=False):
    open_mode = "wb" if binary_mode else "wt"
    with open(path, mode=open_mode) as writer:
        writer.write(data)


def _read_test_file(path, binary_mode=False):
    open_mode = "rb" if binary_mode else "rt"
    with open(path, mode=open_mode) as reader:
        return reader.read()
